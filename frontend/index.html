
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TomTom Route Viewer</title>
  <!-- Self-hosted TomTom SDK only (no external CDNs) -->
  <script>
    // Only load from local static files under /static/vendor/tomtom
    function loadScript(src){
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
      });
    }
    function loadCss(href){
      return new Promise((resolve) => {
        const l = document.createElement('link');
        l.rel = 'stylesheet'; l.href = href; l.onload = resolve; l.onerror = resolve;
        document.head.appendChild(l);
      });
    }
    async function ensureTomTomSDK(){
      if(window.tt) return 'existing';
      // Local static copy (place files under frontend/vendor/tomtom)
      try{
        await loadCss('/static/vendor/tomtom/maps.css');
        await loadScript('/static/vendor/tomtom/maps-web.min.js');
        if(window.tt) return 'local';
      }catch(e){ /* continue */ }
      throw new Error('TomTom SDK local files not found. Place maps-web.min.js and maps.css under frontend/vendor/tomtom/.');
    }
    window.ensureTomTomSDK = ensureTomTomSDK;
  </script>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:12px 16px;border-bottom:1px solid #eee;display:flex;gap:12px;align-items:center}
    #map{position:absolute;top:64px;bottom:0;width:100%}
    .panel{display:flex;gap:8px;align-items:center}
    .badge{padding:2px 8px;border-radius:999px;background:#efefef;font-size:12px}
    .card{position:absolute;top:72px;left:12px;background:#fff;padding:10px 12px;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,0.12);max-width:360px}
    .list{max-height:40vh;overflow:auto;margin-top:8px}
    .step{padding:6px 4px;border-bottom:1px dashed #eee;font-size:13px}
    .foot{font-size:12px;color:#666;margin-top:8px}
    .legend{position:absolute;top:72px;right:12px;background:#fff;padding:8px 10px;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,0.12);min-width:160px}
    .legend-row{display:flex;align-items:center;gap:8px;margin:4px 0;font-size:12px}
    .swatch{width:12px;height:12px;border-radius:2px;border:1px solid #ccc}
  </style>
</head>
<body>
<header>
  <strong>TomTom Route Viewer</strong>
  <div class="panel">
    <label>TomTom API Key:</label>
    <input id="apiKey" placeholder="TT_API_KEY" value="" style="width:260px;padding:6px 8px"/>
    <button id="loadBtn">Load</button>
    <button id="optBtn" title="Show optimized route">Optimize Route</button>
    <button id="navBtn" title="Animate along route">Start Navigation</button>
    <button id="pauseBtn" title="Pause/Resume" disabled>Pause</button>
    <label class="badge" style="display:flex;align-items:center;gap:4px">Speed
      <select id="navSpeed">
        <option value="0.5">0.5x</option>
        <option value="1" selected>1x</option>
        <option value="2">2x</option>
        <option value="4">4x</option>
      </select>
    </label>
    <label class="badge" style="display:flex;align-items:center;gap:4px;cursor:pointer">
      <input type="checkbox" id="snapStops"/> Snap to stops
    </label>
    <label class="badge" style="margin-left:8px">Stops:
      <select id="stopSelect"></select>
    </label>
    <span id="meta" class="badge">—</span>
    <span id="assignmentBadge" class="badge" style="margin-left:8px">Assignment: —</span>
    <label class="badge" style="margin-left:8px">Vehicle:
      <select id="routeSelect"></select>
    </label>
    <label class="badge" style="display:flex;align-items:center;gap:4px;cursor:pointer">
      <input type="checkbox" id="debugShowAll" /> All points
    </label>
    <button id="clearKeyBtn" title="Clear stored key">Clear</button>
  </div>
</header>
<div id="map"></div>
<div class="card" id="info" hidden>
  <div><strong>Route</strong> <span id="routeMeta" class="badge"></span></div>
  <div class="list" id="steps"></div>
  <div class="foot">Click markers to focus. Data from NextBillion; rendered via TomTom.</div>
</div>
<div class="legend" id="legend" hidden></div>

  <script>
  (async function(){
  let sdkSource = 'primary';
  if(window.ensureTomTomSDK){
    try { sdkSource = await window.ensureTomTomSDK(); }
    catch(e){ console.error(e); alert('Failed to load TomTom SDK. See console for details.'); }
  }
  const routeSelect = document.getElementById('routeSelect');
  const stopSelect = document.getElementById('stopSelect');
  const navBtn = document.getElementById('navBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const navSpeed = document.getElementById('navSpeed');
  const snapStops = document.getElementById('snapStops');
  const assignmentBadge = document.getElementById('assignmentBadge');
  const optBtn = document.getElementById('optBtn');
  const debugShowAll = document.getElementById('debugShowAll');

  let map, markers = [], routeLayers = [];
  let apiKeyGlobal = '';
  let selectedSet = null; // number or null
  let geo = null; // current FeatureCollection
  let nav = { playing:false, paused:false, idx:0, path:[], timer:null, marker:null, lastStepShown:null, speed:1, snap:false };

  function query(){
    const params = [];
    if(selectedSet!==null && selectedSet!==undefined) params.push(`set=${encodeURIComponent(selectedSet)}`);
    return params.length ? `?${params.join('&')}` : '';
  }

  // no data dropdown in viewer

  async function loadResponseSummary(){
    const res = await fetch(`/api/summary${query()}`);
    if(!res.ok){
      console.warn('summary failed', res.status);
      document.getElementById('meta').textContent = 'routes: 0 | deliveries: - pcs';
      routeSelect.innerHTML = '';
      return { routes_count: 0, vehicles: [] };
    }
    const s = await res.json();
    document.getElementById('meta').textContent = `routes: ${s.routes_count} | deliveries: ${s?.summary?.delivery?.[0] ?? '-'} pcs`;
    // Populate vehicles from response
    routeSelect.innerHTML = '';
    (s.vehicles||[]).forEach((v, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = `${i+1}: ${v}`;
      routeSelect.appendChild(opt);
    });
    try{
      const savedIdx = localStorage.getItem('TT_SELECTED_ROUTE');
      if(savedIdx !== null && routeSelect.querySelector(`option[value="${savedIdx}"]`)){
        routeSelect.value = savedIdx;
      }
    }catch{}
    // Legend from response
    try{
      const legend = document.getElementById('legend');
      const routeColors = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628'];
      legend.innerHTML='';
      (s.vehicles||[]).forEach((v, i) => {
        const row = document.createElement('div');
        row.className='legend-row';
        const sw = document.createElement('span'); sw.className='swatch'; sw.style.background = routeColors[i % routeColors.length];
        const txt = document.createElement('span'); txt.textContent = v;
        row.appendChild(sw); row.appendChild(txt);
        legend.appendChild(row);
      });
      legend.hidden = false;
    }catch{}
    return s;
  }

  async function loadRequestVehicles(){
    // Use request-raw to populate vehicles list before optimize
    try{
      const req = await fetch(`/api/request-raw${query()}`).then(r=>r.json());
      const vehicles = Array.isArray(req.vehicles) ? req.vehicles.map(v=>v.id || 'vehicle') : [];
      routeSelect.innerHTML = '';
      vehicles.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `${i+1}: ${v}`;
        routeSelect.appendChild(opt);
      });
      document.getElementById('meta').textContent = `assignment: ${selectedSet ?? '—'} | vehicles: ${vehicles.length} | jobs: ${(req.jobs||[]).length}`;
    }catch(e){
      console.warn('Failed loading request vehicles', e);
    }
  }

  // get set from URL or from localStorage; display in badge
  try{
    const u = new URL(window.location.href);
    const qsSet = u.searchParams.get('set');
    selectedSet = qsSet ? Number(qsSet) : (Number(localStorage.getItem('TT_SET_ID')||'')||null);
  }catch{}
  if(selectedSet!=null){ try{ localStorage.setItem('TT_SET_ID', String(selectedSet)); }catch{} }
  assignmentBadge.textContent = `Assignment: ${selectedSet??'—'}`;
  // Before optimize, we will populate vehicles from request file

  // Build fallback LineStrings from step Points ordered by location_index
  function buildFallbackLines(fc){
    const byRoute = new Map();
    for(const f of (fc.features||[])){
      if(f.geometry?.type === 'Point'){
        const ri = f.properties?.route_index;
        const li = f.properties?.location_index ?? 0;
        if(ri == null) continue;
        if(!byRoute.has(ri)) byRoute.set(ri, []);
        byRoute.get(ri).push({ li: Number(li), coord: f.geometry.coordinates });
      }
    }
    const features = [];
    for(const [ri, arr] of byRoute.entries()){
      arr.sort((a,b)=>a.li-b.li);
      const coords = arr.map(x=>x.coord).filter(Array.isArray);
      if(coords.length >= 2){
        features.push({ type:'Feature', geometry:{ type:'LineString', coordinates: coords }, properties:{ route_index: ri, source:'fallback-sequence' } });
      }
    }
    return { type:'FeatureCollection', features };
  }
  async function boot(apiKey){
    if(!apiKey){ alert('Enter your TomTom API key'); return; }
    // Store key and mask field
    try{ localStorage.setItem('TT_API_KEY', apiKey); }catch{}
    const apiKeyEl = document.getElementById('apiKey');
    apiKeyEl.type = 'password';
    apiKeyEl.value = apiKey;
    apiKeyGlobal = apiKey;
    tt.setProductInfo("RouteViewer","1.0.0");
    map = tt.map({
      key: apiKey,
      container: 'map',
      dragPan: true,
      zoom: 10,
      center: [28.0473, -26.171] // Johannesburg-ish fallback
    });
    // Expose for console debugging: use window._ttMap in DevTools
    try { window._ttMap = map; } catch(e) {}
    map.addControl(new tt.NavigationControl());

    // First, load request points and vehicles AFTER style is ready to avoid race on first load
    let hasValidServerLines = false;
    let fallbackLines = null;
    const loadReq = async () => { try{ await loadRequestPoints(); await loadRequestVehicles(); }catch(e){ console.warn('loadReq failed', e);} };
    if (typeof map.isStyleLoaded === 'function' ? map.isStyleLoaded() : map.loaded()) {
      loadReq();
    } else {
      map.once('load', loadReq);
    }

    function addOrUpdateLayers() {
      // If routes data not ready yet, only ensure focus-point and return
      if(!geo || !geo.features){
        if(!map.getSource('focus-point')){
          map.addSource('focus-point', { type: 'geojson', data: { type:'FeatureCollection', features: [] } });
        }
        if(!map.getLayer('focus-point')){
          map.addLayer({ id:'focus-point', type:'circle', source:'focus-point', paint:{ 'circle-radius':9,'circle-color':'#FFD400','circle-stroke-color':'#000','circle-stroke-width':2 } });
        }
        return;
      }
      // Add the entire FeatureCollection as a source
      if(map.getSource('routes')){
        map.getSource('routes').setData(geo);
      } else {
        map.addSource('routes', { type: 'geojson', data: geo });
      }
      // Add line layers: all routes dimmed + selected route highlighted
      const routeColors = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628'];
      if(!map.getLayer('route-lines-all')) map.addLayer({
        id: 'route-lines-all',
        type: 'line',
        source: 'routes',
        filter: ['==', ['geometry-type'], 'LineString'],
        paint: {
          'line-width': 3,
          'line-opacity': 0.85,
          'line-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
        }
      });
      if(!map.getLayer('route-lines-selected')) map.addLayer({
        id: 'route-lines-selected',
        type: 'line',
        source: 'routes',
        filter: ['all', ['==', ['geometry-type'], 'LineString'], ['==', ['get','route_index'], 0]],
        paint: {
          'line-width': 6,
          'line-opacity': 1,
          'line-blur': 0.2,
          'line-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
        }
      });

      // Fallback derived lines (if server LineStrings are missing/empty)
      if(fallbackLines && (fallbackLines.features?.length || 0) > 0){
        if(map.getSource('fallback-lines')){
          map.getSource('fallback-lines').setData(fallbackLines);
        } else {
          map.addSource('fallback-lines', { type:'geojson', data: fallbackLines });
        }
        if(!map.getLayer('fallback-lines-all')) map.addLayer({
          id: 'fallback-lines-all', type:'line', source:'fallback-lines',
          layout: { 'line-cap':'round', 'line-join':'round' },
          paint: {
            'line-width': 3,
            'line-opacity': 0.85,
            'line-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
          }
        });
        if(!map.getLayer('fallback-lines-selected')) map.addLayer({
          id: 'fallback-lines-selected', type:'line', source:'fallback-lines',
          filter: ['==', ['get','route_index'], 0],
          layout: { 'line-cap':'round', 'line-join':'round' },
          paint: {
            'line-width': 6,
            'line-opacity': 1,
            'line-blur': 0.2,
            'line-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
          }
        });
      }

      // Add circle layer for step points
      if(!map.getLayer('route-points')) map.addLayer({
        id: 'route-points',
        type: 'circle',
        source: 'routes',
        filter: ['all', ['==', ['geometry-type'], 'Point'], ['==', ['get','route_index'], 0]],
        paint: {
          'circle-radius': 6,
          'circle-stroke-width': 1,
          'circle-stroke-color': '#ffffff',
          'circle-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
        }
      });

      // Focus point overlay (single feature)
      if(!map.getSource('focus-point')){
        map.addSource('focus-point', { type: 'geojson', data: { type:'FeatureCollection', features: [] } });
      }
      if(!map.getLayer('focus-point')){
        map.addLayer({
          id: 'focus-point',
          type: 'circle',
          source: 'focus-point',
          paint: {
            'circle-radius': 9,
            'circle-color': '#FFD400',
            'circle-stroke-color': '#000',
            'circle-stroke-width': 2
          }
        });
      }

      // Fit map to selected route
      if(geo){
        const bbox = getBBoxForRoute(geo, Number(routeSelect.value||0));
        if(bbox){ map.fitBounds(bbox, { padding: 60 }); }
      }

      // Build steps list for selected route (default 0)
      const stepsEl = document.getElementById('steps');
      function humanize(sec){
        const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = sec%60;
        return [h?`${h}h`:null, m?`${m}m`:null, s?`${s}s`:null].filter(Boolean).join(' ');
      }
      async function reverseGeocode(lat, lon){
        try{
          const url = `https://api.tomtom.com/search/2/reverseGeocode/${lat},${lon}.json?key=${encodeURIComponent(apiKeyGlobal)}&radius=50`;
          const r = await fetch(url);
          if(!r.ok) return null;
          const j = await r.json();
          return j?.addresses?.[0]?.address?.freeformAddress || null;
        }catch{ return null; }
      }

      function setFocus(lng, lat){
        const fc = { type:'FeatureCollection', features:[{ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:{} }]};
        const src = map.getSource('focus-point');
        if(src && src.setData){ src.setData(fc); }
      }

      function ensureLayersPresent(){
        if(!map.getSource('routes') || !map.getLayer('route-lines-all') || !map.getLayer('route-lines-selected') || !map.getLayer('route-points')){
          addOrUpdateLayers();
        }
      }

      function renderRoute(idx){
        ensureLayersPresent();
        stepsEl.innerHTML = '';
        const steps = (geo?.features||[]).filter(f => f.geometry?.type === 'Point' && f.properties?.route_index === idx);
        console.log('[renderRoute] idx=', idx, 'pointsForRoute=', steps.length);
        const meta = (geo?.features||[]).find(f => f.geometry?.type==='LineString' && f.properties?.route_index===idx)?.properties;
        document.getElementById('routeMeta').textContent = meta ? `vehicle: ${meta.vehicle} | duration: ${humanize(meta.duration||0)}` : '';
        for(const s of steps){
          const div = document.createElement('div');
          div.className = 'step';
          const [lng, lat] = s.geometry.coordinates;
          div.textContent = `${s.properties.step_type || 'step'} — ${lat.toFixed(5)}, ${lng.toFixed(5)} ${s.properties.id ? '('+s.properties.id+')':''}`;
          div.onclick = async () => {
            setFocus(lng, lat);
            map.flyTo({ center: [lng, lat], zoom: 13 });
            const name = await reverseGeocode(lat, lng);
            if(name){ div.textContent = `${s.properties.step_type || 'step'} — ${lat.toFixed(5)}, ${lng.toFixed(5)} ${s.properties.id ? '('+s.properties.id+')':''} • ${name}`; }
          };
          stepsEl.appendChild(div);
        }
        // Filter visible features to selected route
        if(map.getLayer('route-points')){
          if (debugShowAll && debugShowAll.checked) {
            map.setFilter('route-points', ['==', ['geometry-type'], 'Point']);
          } else if(steps.length > 0){
            map.setFilter('route-points', ['all', ['==', ['geometry-type'], 'Point'], ['==', ['get','route_index'], idx]]);
          } else {
            console.warn('[renderRoute] No points for route', idx, '— showing all points');
            map.setFilter('route-points', ['==', ['geometry-type'], 'Point']);
          }
        }
        if(map.getLayer('route-lines-selected')){
          map.setFilter('route-lines-selected', ['all', ['==', ['geometry-type'], 'LineString'], ['==', ['get','route_index'], idx]]);
        }
        if(map.getLayer('fallback-lines-selected')){
          map.setFilter('fallback-lines-selected', ['==', ['get','route_index'], idx]);
        }
        const rb = getBBoxForRoute(geo, idx);
        if(rb){ map.fitBounds(rb, { padding: 60 }); }
        try{ localStorage.setItem('TT_SELECTED_ROUTE', String(idx)); }catch{}
      }
      renderRoute(Number(routeSelect.value||0));
      document.getElementById('info').hidden = false;

      // Update on select change
      routeSelect.onchange = () => { renderRoute(Number(routeSelect.value||0)); try{ renderStopsList(); }catch{} };
      if (debugShowAll) debugShowAll.onchange = () => renderRoute(Number(routeSelect.value||0));

      // Surface tile/auth errors
      map.on('error', (e) => {
        const msg = String(e?.error?.message || e?.error || 'Map error');
        if(/401|403/.test(msg)){
          alert('TomTom tiles failed (401/403). Check API key permissions and allowed domains for localhost/127.0.0.1.');
        } else {
          console.warn('Map error:', e);
        }
      });
      // Click on step points to focus
      try{
        map.off('click', 'route-points', ()=>{}); // no-op to clear duplicates safely
      }catch{}
      map.on('click', 'route-points', (e) => {
        const f = e.features && e.features[0];
        if(!f) return;
        const [lng, lat] = f.geometry.coordinates;
        map.flyTo({ center: [lng, lat], zoom: 13 });
      });
    }

    // Ensure layers are added after the style is truly ready
    let layersAdded = false;
    const safeAddLayers = () => { if(layersAdded) return; layersAdded = true; addOrUpdateLayers(); };
    if (typeof map.isStyleLoaded === 'function' ? map.isStyleLoaded() : map.loaded()) {
      // style is already loaded
      safeAddLayers();
    } else {
      map.once('load', safeAddLayers);
    }
  }

  async function loadOptimizedRoutes(){
    // Load response summary + routes and render
    const s = await loadResponseSummary();
    if(!map) return;
    const rr = await fetch(`/api/routes${query()}`);
    if(!rr.ok){ console.warn('routes failed', rr.status); return; }
    geo = await rr.json();
    if(!geo || geo.type !== 'FeatureCollection'){ console.warn('invalid geojson from routes'); return; }
    const src = map.getSource('routes');
    if(src && src.setData){ src.setData(geo); }
    else {
      map.addSource('routes', { type:'geojson', data: geo });
    }
    const hasValidServerLines = (geo.features||[]).some(f => f.geometry?.type==='LineString' && Array.isArray(f.geometry.coordinates) && f.geometry.coordinates.length>=2);
    const fb = hasValidServerLines ? null : buildFallbackLines(geo);
    const fbSrc = map.getSource('fallback-lines');
    if(fb && fbSrc && fbSrc.setData) fbSrc.setData(fb);
    if(!fb && fbSrc && fbSrc.setData) fbSrc.setData({ type:'FeatureCollection', features: [] });
    // Keep request points above lines
    try{ map.moveLayer('req-points'); }catch{}
    // Ensure rendering layers exist (duplicate minimal logic)
    const routeColors = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628'];
    if(!map.getLayer('route-lines-all')) map.addLayer({
      id: 'route-lines-all', type: 'line', source: 'routes',
      filter: ['==', ['geometry-type'], 'LineString'],
      paint: {
        'line-width': 3,
        'line-opacity': 0.85,
        'line-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
      }
    });
    if(!map.getLayer('route-lines-selected')) map.addLayer({
      id: 'route-lines-selected', type: 'line', source: 'routes',
      filter: ['all', ['==', ['geometry-type'], 'LineString'], ['==', ['get','route_index'], 0]],
      paint: {
        'line-width': 6,
        'line-opacity': 1,
        'line-blur': 0.2,
        'line-color': ['match', ['get','route_index'], 0, routeColors[0], 1, routeColors[1], 2, routeColors[2], 3, routeColors[3], 4, routeColors[4], routeColors[5]]
      }
    });
    if(fb){
      if(map.getSource('fallback-lines')) map.getSource('fallback-lines').setData(fb);
      else map.addSource('fallback-lines', { type:'geojson', data: fb });
      if(!map.getLayer('fallback-lines-all')) map.addLayer({ id: 'fallback-lines-all', type:'line', source:'fallback-lines', layout:{ 'line-cap':'round','line-join':'round' }, paint:{ 'line-width':3,'line-opacity':0.85,'line-color':['match',['get','route_index'],0,routeColors[0],1,routeColors[1],2,routeColors[2],3,routeColors[3],4,routeColors[4],routeColors[5]] }});
      if(!map.getLayer('fallback-lines-selected')) map.addLayer({ id:'fallback-lines-selected', type:'line', source:'fallback-lines', filter:['==',['get','route_index'],0], layout:{ 'line-cap':'round','line-join':'round' }, paint:{ 'line-width':6,'line-opacity':1,'line-blur':0.2,'line-color':['match',['get','route_index'],0,routeColors[0],1,routeColors[1],2,routeColors[2],3,routeColors[3],4,routeColors[4],routeColors[5]] }});
    }
    // Reapply selection and fit bounds
    if(typeof routeSelect.onchange === 'function') routeSelect.onchange();
    const idx = Number(routeSelect.value||0);
    const bbox = getBBoxForRoute(geo, idx);
    if(bbox){ map.fitBounds(bbox, { padding: 60 }); }
    // Build stops dropdown for selected vehicle
    renderStopsList();
    // Prepare navigation path for current vehicle
    buildNavPath();
  }

  // Build the stops list (start -> jobs -> end) for the selected vehicle
  function getStopsForVehicle(){
    // Build stops strictly in the order provided by the optimized response
    if(!geo || !geo.features) return [];
    const vIdx = Number(routeSelect.value||0);
    const ordered = [];
    for(const f of geo.features){
      if(!(f && f.geometry && f.geometry.type==='Point')) continue;
      if(Number(f.properties?.route_index) !== vIdx) continue;
      const [lng, lat] = f.geometry.coordinates || [];
      const t = f.properties?.step_type || 'stop';
      const id = f.properties?.id;
      const label = (t==='start'||t==='end') ? t : (id ?? 'job');
      ordered.push({ label, lng, lat, type: t });
    }
    return ordered;
  }

  function renderStopsList(){
    if(!stopSelect) return;
    const stops = getStopsForVehicle();
    stopSelect.innerHTML = '';
    if(!stops.length){
      const opt = document.createElement('option');
      opt.textContent = '(no stops)'; opt.value='';
      stopSelect.appendChild(opt);
      stopSelect.disabled = true;
      return;
    }
    stopSelect.disabled = false;
    // Add a placeholder so the first real selection (e.g., start) always triggers change
    const ph = document.createElement('option');
    ph.textContent = 'Select stop…'; ph.value = '';
    ph.disabled = true; ph.selected = true; ph.hidden = true;
    stopSelect.appendChild(ph);
    stops.forEach((s, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = `${i+1}. ${s.label} (${s.lat?.toFixed?.(4)||'?'}, ${s.lng?.toFixed?.(4)||'?'})`;
      stopSelect.appendChild(opt);
    });
  }

  // Jump to stop when selected
  if(stopSelect){
    const goToIdx = (idx) => {
      const stops = getStopsForVehicle();
      const s = stops[idx];
      if(!s) return;
      // set focus
      const fc = { type:'FeatureCollection', features:[{ type:'Feature', geometry:{ type:'Point', coordinates:[s.lng, s.lat] }, properties:{} }] };
      const src = map.getSource && map.getSource('focus-point');
      if(src && src.setData) src.setData(fc);
      map && map.flyTo && map.flyTo({ center:[s.lng, s.lat], zoom: 13 });
    };
    stopSelect.onchange = () => {
      const v = stopSelect.value;
      if(v === '') return; // placeholder
      const idx = Number(v);
      goToIdx(idx);
    };
    // Optional: clicking the select again will re-center on the current selection
    stopSelect.addEventListener('click', () => {
      const v = stopSelect.value; if(v==='') return; goToIdx(Number(v));
    });
  }
  // Haversine distance in meters
  function distMeters(a,b){
    const toRad = x=>x*Math.PI/180;
    const R=6371000; const dLat=toRad(b[1]-a[1]); const dLng=toRad(b[0]-a[0]);
    const s1=toRad(a[1]); const s2=toRad(b[1]);
    const h = Math.sin(dLat/2)**2 + Math.cos(s1)*Math.cos(s2)*Math.sin(dLng/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  }
  function buildNavPath(){
    nav.path = [];
    nav.idx = 0;
    const vIdx = Number(routeSelect.value||0);
    if(!geo||!geo.features) return;
    const line = geo.features.find(f => f.geometry && f.geometry.type==='LineString' && Number(f.properties?.route_index)===vIdx);
    let coords = (line && Array.isArray(line.geometry.coordinates)) ? line.geometry.coordinates.slice() : [];
    // If snapping, or no lines, use stop points as path
    if(nav.snap || coords.length<2){
      const stops = getStopsForVehicle();
      coords = stops.map(s=>[s.lng,s.lat]);
    }
    // Densify for smooth animation (~100m between points)
    const maxStep = 120; // meters
    for(let i=0;i<coords.length-1;i++){
      const a = coords[i], b = coords[i+1];
      const d = distMeters(a,b);
      const steps = Math.max(1, Math.ceil(d/maxStep));
      for(let k=0;k<steps;k++){
        const t = k/steps;
        nav.path.push([a[0]+(b[0]-a[0])*t, a[1]+(b[1]-a[1])*t]);
      }
    }
    nav.path.push(coords[coords.length-1]);
  }
  function ensureNavMarker(){
    if(nav.marker) return nav.marker;
    const el = document.createElement('div');
    el.className = 'nav-marker';
    el.style.width = '22px'; el.style.height='22px'; el.style.borderRadius='50%';
    el.style.background = '#FFD400'; el.style.border='2px solid #000';
    el.style.boxShadow='0 0 6px rgba(0,0,0,0.35)';
    const dot = document.createElement('div');
    dot.style.width='6px'; dot.style.height='6px'; dot.style.borderRadius='50%'; dot.style.background='#000';
    dot.style.position='absolute'; dot.style.left='50%'; dot.style.top='50%'; dot.style.transform='translate(-50%,-50%)';
    el.appendChild(dot);
    nav.marker = new tt.Marker({ element: el }).setLngLat([0,0]).addTo(map);
    return nav.marker;
  }
  function stopNavigation(){
    if(nav.timer){ clearInterval(nav.timer); nav.timer=null; }
    nav.playing=false; nav.paused=false;
    if(navBtn) navBtn.textContent = 'Start Navigation';
    if(pauseBtn){ pauseBtn.disabled = true; pauseBtn.textContent = 'Pause'; }
  }
  function setNavTimer(){
    if(nav.timer){ clearInterval(nav.timer); nav.timer=null; }
    const fps = nav.snap ? 1 : 30; // snap moves stop-to-stop; non-snap smooth
    const interval = (nav.snap ? Math.max(250, 1200/nav.speed) : 1000/fps);
    nav.timer = setInterval(()=>{
      if(nav.idx >= nav.path.length){ stopNavigation(); return; }
      // Advance
      if(nav.snap){
        // Jump to next significant point
        nav.idx += 1; // one path point per tick (path is stops when snapping)
      } else {
        nav.idx += Math.max(0.25, nav.speed); // speed indexes per tick
      }
      const p = nav.path[Math.min(Math.floor(nav.idx), nav.path.length-1)];
      if(!p) return;
      try{ nav.marker.setLngLat(p); }catch{}
      // Follow marker
      try{ map.easeTo({ center:p, duration:interval, zoom: Math.max(map.getZoom()||0, 12.5) }); }catch{}
      // Show step popup when close to a stop
      try{
        const stops = getStopsForVehicle();
        for(const s of stops){
          if(s.label===nav.lastStepShown) continue;
          if(distMeters(p,[s.lng,s.lat]) < (nav.snap?5:80)){
            new tt.Popup({closeButton:true}).setLngLat([s.lng,s.lat]).setHTML(s.label).addTo(map);
            nav.lastStepShown = s.label; break;
          }
        }
      }catch{}
    }, interval);
  }
  function startNavigation(){
    if(!map) return;
    if(!nav.path || nav.path.length<2){ buildNavPath(); }
    if(!nav.path || nav.path.length<2){ alert('No route to navigate. Click Optimize Route first.'); return; }
    ensureNavMarker();
    nav.playing=true; nav.paused=false; if(navBtn) navBtn.textContent='Stop Navigation';
    if(pauseBtn){ pauseBtn.disabled=false; pauseBtn.textContent='Pause'; }
    nav.idx=0; nav.lastStepShown=null;
    setNavTimer();
  }
  if(navBtn){
    navBtn.onclick = () => { if(nav.playing) stopNavigation(); else startNavigation(); };
  }
  // Rebuild nav path when vehicle changes or routes reload
  if(routeSelect){ routeSelect.addEventListener('change', ()=>{ buildNavPath(); }); }
  if(navSpeed){ navSpeed.onchange = () => { nav.speed = parseFloat(navSpeed.value||'1')||1; if(nav.playing && !nav.paused){ setNavTimer(); } }; }
  if(snapStops){ snapStops.onchange = () => { nav.snap = !!snapStops.checked; buildNavPath(); if(nav.playing && !nav.paused){ setNavTimer(); } }; }
  if(pauseBtn){
    pauseBtn.onclick = () => {
      if(!nav.playing) return;
      if(!nav.paused){
        // pause
        nav.paused = true; if(nav.timer){ clearInterval(nav.timer); nav.timer=null; }
        pauseBtn.textContent = 'Resume';
      } else {
        // resume
        nav.paused = false; pauseBtn.textContent = 'Pause'; setNavTimer();
      }
    };
  }
  // Always refresh stops list when vehicle selection changes
  if(routeSelect){
    routeSelect.addEventListener('change', () => {
      try{ renderStopsList(); }catch{}
    });
  }

  async function loadRequestPoints(){
    try{
      const r = await fetch(`/api/request-points${query()}`);
      if(!r.ok) return; // no request file, skip silently
      const fc = await r.json();
      // Ensure style is loaded before adding layers
      if(!(typeof map.isStyleLoaded==='function'? map.isStyleLoaded(): map.loaded())){
        await new Promise(res => map.once('load', res));
      }
      // Add/Update source
      if(map.getSource('request')) map.getSource('request').setData(fc);
      else map.addSource('request', { type:'geojson', data: fc });
      // Always add clear circle layer for visibility
      if(!map.getLayer('req-points')){
        map.addLayer({
          id:'req-points', type:'circle', source:'request',
          paint:{
            'circle-radius': ['match',['get','point_type'], 'start', 7, 'end', 7, 6],
            'circle-stroke-width': 2,
            'circle-stroke-color': '#000',
            'circle-color': ['match',['get','point_type'], 'start', '#2ecc71', 'end', '#e74c3c', /*job*/ '#1e90ff']
          }
        });
      }
      // Try a 3D-like icon layer above circles
      try{
        await ensurePinIcons();
        if(!map.getLayer('req-icons')){
          map.addLayer({
            id:'req-icons', type:'symbol', source:'request',
            layout:{
              'icon-image': ['match',['get','point_type'],'start','pin-start','end','pin-end','job','pin-job','pin-job'],
              'icon-allow-overlap': true,
              'icon-size': ['interpolate',['linear'],['zoom'], 6, 0.6, 12, 1.1]
            }
          });
        }
        try{ map.moveLayer('req-icons'); }catch{}
      }catch(e){ /* fallback remains circle */ }
      // Keep request points above routes
      try{ map.moveLayer('req-points'); }catch{}
      // Fit to all request points
      const bbox = (function(){
        if(!fc?.features?.length) return null; let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for(const f of fc.features){ const [x,y]=f.geometry.coordinates; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);} return [[minX,minY],[maxX,maxY]];})();
      if(bbox) map.fitBounds(bbox, { padding: 60 });
    }catch(e){ console.warn('request points load failed', e); }
  }

  // Create simple 3D-looking circular pins using canvas radial gradients
  let _pinIconsReady = false;
  async function ensurePinIcons(){
    if(_pinIconsReady) return;
    // Wait for style ready so addImage works
    if(!(typeof map.isStyleLoaded==='function'? map.isStyleLoaded(): map.loaded())){
      await new Promise(res => map.once('load', res));
    }
    const px = Math.max(48, Math.floor((window.devicePixelRatio||1)*36));
    function makePin(color){
      const c=document.createElement('canvas'); c.width=c.height=px; const ctx=c.getContext('2d');
      const cx=px*0.5, cy=px*0.38; const r=px*0.28; const tipY = cy + r + r*0.95;
      // Shadow
      ctx.beginPath(); ctx.ellipse(cx, tipY, r*0.7, r*0.35, 0, 0, Math.PI*2);
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.filter='blur(1.5px)'; ctx.fill(); ctx.filter='none';
      // Pin head gradient
      const g=ctx.createRadialGradient(cx-r*0.5, cy-r*0.6, r*0.15, cx, cy, r);
      g.addColorStop(0, '#fff');
      g.addColorStop(0.15, '#fff');
      g.addColorStop(0.25, color);
      g.addColorStop(1, shade(color, -35));
      // Pin path (teardrop)
      ctx.beginPath();
      ctx.arc(cx, cy, r, Math.PI*0.15, Math.PI*0.85, true);
      ctx.quadraticCurveTo(cx - r*0.9, cy + r*0.9, cx, tipY);
      ctx.quadraticCurveTo(cx + r*0.9, cy + r*0.9, cx + r*Math.cos(Math.PI*0.15), cy + r*Math.sin(Math.PI*0.15));
      ctx.closePath();
      ctx.fillStyle=g; ctx.fill();
      ctx.lineWidth=Math.max(2, px*0.04); ctx.strokeStyle='#124d7a'; ctx.stroke();
      // Inner white circle
      ctx.beginPath(); ctx.arc(cx, cy, r*0.45, 0, Math.PI*2); ctx.fillStyle='#ffffff'; ctx.fill();
      ctx.lineWidth=Math.max(1, px*0.025); ctx.strokeStyle=shade(color,-25); ctx.stroke();
      return c;
    }
    function shade(hex, lum){
      // simple hex shade util lum in [-100..100]
      let h=hex.replace(/[^0-9a-f]/gi,''); if(h.length<6){ h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; }
      let rgb='#'; for(let i=0;i<3;i++){ let c=parseInt(h.substr(i*2,2),16); c=Math.max(0,Math.min(255, c + Math.round(255*lum/100))); rgb+=('00'+c.toString(16)).slice(-2); } return rgb;
    }
    const startImg = makePin('#2ecc71');
    const jobImg = makePin('#1e90ff');
    const endImg = makePin('#e74c3c');
    if(!map.hasImage('pin-start')) map.addImage('pin-start', startImg, { pixelRatio: 1 });
    if(!map.hasImage('pin-job')) map.addImage('pin-job', jobImg, { pixelRatio: 1 });
    if(!map.hasImage('pin-end')) map.addImage('pin-end', endImg, { pixelRatio: 1 });
    _pinIconsReady = true;
  }

  function getBBox(geo){
    if(!geo?.features?.length) return null;
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const f of geo.features){
      if(f.geometry.type === 'Point'){
        const [x,y] = f.geometry.coordinates;
        minX = Math.min(minX, x); minY = Math.min(minY, y);
        maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
      } else if(f.geometry.type === 'LineString'){
        for(const [x,y] of f.geometry.coordinates){
          minX = Math.min(minX, x); minY = Math.min(minY, y);
          maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
        }
      }
    }
    return [[minX, minY], [maxX, maxY]];
  }
  function getBBoxForRoute(geo, idx){
    const feats = geo?.features?.filter(f => (f.geometry.type==='LineString' || f.geometry.type==='Point') && f.properties?.route_index===idx) || [];
    if(!feats.length) return null;
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const f of feats){
      if(f.geometry.type==='Point'){
        const [x,y]=f.geometry.coordinates;
        minX=Math.min(minX,x); minY=Math.min(minY,y);
        maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);
      } else if(f.geometry.type==='LineString'){
        for(const [x,y] of f.geometry.coordinates){
          minX=Math.min(minX,x); minY=Math.min(minY,y);
          maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);
        }
      }
    }
    return [[minX,minY],[maxX,maxY]];
  }
  

  document.getElementById('loadBtn').onclick = async () => {
    const key = document.getElementById('apiKey').value.trim();
    if(map && apiKeyGlobal === key){
      // Only load request points + vehicles; do NOT load routes yet
      await loadRequestPoints();
      await loadRequestVehicles();
      return;
    }
    try{ if(map && typeof map.remove === 'function') map.remove(); }catch{}
    map = null;
    await boot(key);
    // Intentionally not loading routes here; Optimize button will load them
  };
  // Optimize: reload routes for current selection (keeps request points visible)
  optBtn.onclick = async () => {
    if(!map){ alert('Load the map first'); return; }
    await loadOptimizedRoutes();
  };
  // Pressing Enter in the API key field triggers Load
  document.getElementById('apiKey').addEventListener('keydown', (e) => {
    if(e.key === 'Enter') document.getElementById('loadBtn').click();
  });
  // Restore stored key (masked), do not auto-load
  try{
    const saved = localStorage.getItem('TT_API_KEY');
    if(saved){ const el = document.getElementById('apiKey'); el.type = 'password'; el.value = saved; }
  }catch{}
  // Clear key button
  document.getElementById('clearKeyBtn').onclick = () => {
    try{ localStorage.removeItem('TT_API_KEY'); }catch{}
    const el = document.getElementById('apiKey');
    el.type = 'text'; el.value = '';
  };
  if(sdkSource && sdkSource !== 'primary'){
    const badge = document.getElementById('meta');
    badge.textContent += ` | sdk: ${sdkSource}`;
  }
  // Legend is rebuilt in response summary

  // Handle data version changes
  const dataSelectEl = null; // removed in viewer

  // Handle set changes
  const setSelectEl = null; // removed in viewer

  // Upload CSVs to selected set
  if(false){ // upload removed
    const sid = setSelect.value ? Number(setSelect.value) : null;
    if(!sid){ alert('Select a set first'); return; }
    const jobs = document.getElementById('jobsFile').files[0] || null;
    const vehicles = document.getElementById('vehiclesFile').files[0] || null;
    if(!jobs && !vehicles){ alert('Choose at least one CSV to upload'); return; }
    const fd = new FormData();
    if(jobs) fd.append('jobs', jobs);
    if(vehicles) fd.append('vehicles', vehicles);
    const r = await fetch(`/api/mock-sets/${encodeURIComponent(sid)}/upload`, { method: 'POST', body: fd });
    const j = await r.json();
    // Show simple previews below
    function renderTable(elId, prev){
      const el = document.getElementById(elId);
      if(!el) return;
      const rows = prev?.rows || [];
      el.innerHTML = rows.length ? `<table border="1" cellpadding="4">${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('')}</table>` : '<em>No preview</em>';
    }
    renderTable('jobsPreview', j.preview?.jobs);
    renderTable('vehiclesPreview', j.preview?.vehicles);
    alert('Upload complete');
  }

  // Click on step points to focus and reverse geocode
  try{
    map.on('click', 'route-points', async (e) => {
      const f = e.features && e.features[0];
      if(!f) return;
      const [lng, lat] = f.geometry.coordinates;
      if(map.getSource('focus-point')){
        const fc = { type:'FeatureCollection', features:[{ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:{} }]};
        map.getSource('focus-point').setData(fc);
      }
      map.flyTo({ center: [lng, lat], zoom: 13 });
      const name = await (async()=>{ try{ const u = `https://api.tomtom.com/search/2/reverseGeocode/${lat},${lng}.json?key=${encodeURIComponent(apiKeyGlobal)}&radius=50`; const r = await fetch(u); if(!r.ok) return null; const j=await r.json(); return j?.addresses?.[0]?.address?.freeformAddress||null; }catch{return null;} })();
      if(name){ new tt.Popup({ closeButton: true }).setLngLat([lng,lat]).setHTML(name).addTo(map); }
    });
    map.on('click', 'req-points', async (e) => {
      const f = e.features && e.features[0];
      if(!f) return;
      const [lng, lat] = f.geometry.coordinates;
      if(map.getSource('focus-point')){
        const fc = { type:'FeatureCollection', features:[{ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:{} }]};
        map.getSource('focus-point').setData(fc);
      }
      map.flyTo({ center: [lng, lat], zoom: 13 });
    });
    // Also allow clicking on 3D icons layer
    map.on('click', 'req-icons', async (e) => {
      const f = e.features && e.features[0];
      if(!f) return;
      const [lng, lat] = f.geometry.coordinates;
      if(map.getSource('focus-point')){
        const fc = { type:'FeatureCollection', features:[{ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:{} }]};
        map.getSource('focus-point').setData(fc);
      }
      map.flyTo({ center: [lng, lat], zoom: 13 });
    });
  }catch{}
})();
</script>
</body>
</html>
